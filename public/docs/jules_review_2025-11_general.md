# 2025年11月版レビュー  
## Googleの自律型コーディングエージェント「Jules」とは？

### この記事の要点（3行）

1. JulesはGitHubリポジトリを丸ごと預けて、バグ修正や機能追加のPull Request（PR）を自動で作ってくれる「非同期コーディングエージェント」です。  
2. 無料プランから始められ、有料のGoogle AI Pro / Ultraでは、利用できるタスク数やモデル（Gemini 3 Pro）が強化されます。  
3. プライベートリポジトリのコードはモデルの再学習には使われないと説明されており、仕様駆動開発と組み合わせると「仕様を書いて任せる」開発スタイルを作りやすくなります。  

---

## 1. Julesの概要

Julesは、Googleが提供するAIベースの**自律型コーディングエージェント**です。  
一般的な「チャットで会話しながらコードを書いてもらうツール」とは性質が異なり、次のような使い方を想定しています。

- 対象となるGitHubリポジトリをJulesに接続する  
- 「このバグを直して」「この機能を実装して」などのタスクをテキストで依頼する  
- JulesはGoogle側の実行環境でコードをクローンし、計画 → 実装 → テスト → PR作成まで自動で行う  
- 開発者は、そのPRをレビューしてマージするだけ  

ポイントは、**「対話」ではなく「仕事の丸投げ」寄りの設計**になっていることです。  
1タスクの粒度は、ファイルをまたぐ修正やテスト追加など、PR1本分のまとまった変更が想定されています。

また、Jules内部には、実装を行うエージェントと、その成果物をチェックする「Critic（批評）エージェント」が存在し、  
AI同士でセルフレビューを行ってからPRを返す仕組みになっています。

---

## 2. コスト（料金とタスク上限）

### 2.1 プラン構成のイメージ

2025年11月時点では、Julesはおおまかに次の3レベルで提供されています。

- **Jules（無料プラン）**  
  - 月額：0円  
  - 1日のタスク上限：おおよそ15タスク前後  
  - 同時に処理できるタスク数：数件程度  

- **Jules in Google AI Pro**  
  - 月額：数千円クラス（世界各地域で価格帯は若干異なる）  
  - 1日のタスク上限：無料より大幅に多く、数十〜100タスク程度  
  - 複数タスクを並行して走らせやすい  

- **Jules in Google AI Ultra**  
  - 月額：エンタープライズ向けの高価格帯  
  - 1日のタスク上限：さらに多く、チームで大量にタスクを回す用途を想定  
  - 最新モデル（Gemini 3 Proなど）を優先的に利用可能  

※具体的なタスク数・料金はプランやリージョンにより変動するため、実利用時は公式の料金ページを確認する必要があります。

### 2.2 コスト感と向き・不向き

- **無料プラン**  
  - 「どんなツールか試してみたい」「個人開発の一部タスクだけ任せたい」といった用途に向きます。  
  - 1日あたりのタスク数はそれほど多くないため、日常業務のほとんどを任せるには不足しがちです。  

- **Google AI Pro**  
  - 個人開発者や小規模チームが、「日々の開発の一部（リファクタリングやテスト追加など）をJulesに任せる」用途にフィットします。  
  - 仕様の整理やPRレビューといった人間の作業を残しつつ、「実装とテスト」をオフロードしたいときの現実的な選択肢です。  

- **Google AI Ultra**  
  - 大規模組織や、複数プロジェクトでJulesを前提に回すようなケース向きです。  
  - セキュリティアップデートや依存パッケージ更新など、定型的なメンテナンスタスクを大量に流す場合に効果が高くなります。  

---

## 3. 利用AI（どのモデルが動いているのか）

### 3.1 ベースはGemini 2.5 Pro

Julesのベースとなるモデルは、長いコンテキスト（大きなプロジェクト全体）を扱える**Gemini 2.5 Pro**です。  

特徴としては、次のような点が挙げられます。

- ソースコードやドキュメントをまとめて読み込んだ上で、タスクを計画できる  
- マルチモーダル対応（テキストに加え、画像なども扱える）  
- コード生成・リファクタリング・テストコード作成など、ソフトウェア開発向けの能力が強化されている  

Julesが「リポジトリ全体を把握してから、変更計画を立てる」スタイルを取れるのは、この長コンテキストモデルが前提にあるためです。

### 3.2 Gemini 3 Proの位置づけ

2025年時点では、より新しい**Gemini 3 Pro**が順次Julesにも展開されています。  

- Pro / Ultraプランでは、プロジェクトやタスクごとに  
  - Gemini 2.5 Pro  
  - Gemini 3 Pro  
  を切り替えられる構成が採用されつつあります。  
- Gemini 3 Proでは、  
  - 長いタスクの途中で「迷子になる」ケースの減少  
  - 複雑な仕様や曖昧な指示に対する、より安定した理解  
  といった改善が報告されています。  

実務的には、次のような使い分けがイメージしやすいです。

- 軽いバグ修正や小さな変更 → Gemini 2.5 Pro  
- 大規模なリファクタリングや複数ステップにわたるマイグレーション → Gemini 3 Pro  

---

## 4. 再学習について（コードは学習に使われるのか？）

### 4.1 プライベートリポジトリ

多くの開発者が気にするのが「**自分たちのコードがAIの再学習に使われないか**」という点です。  

Julesについては、公式情報などで次のように説明されています。

- Julesは**プライベートがデフォルト**であり、  
- **プライベートリポジトリのコードは、Geminiなどの基盤モデルの再学習には使われない**  
- コードは、タスクを実行する一時的な実行環境で扱われ、他のユーザーと共有されない  

このため、社内システムやクローズドなプロダクトのコードであっても、プライベートリポジトリであれば再学習のリスクは低いとされています。

### 4.2 公開リポジトリ

一方、**公開リポジトリ**のコードは、そもそも誰でも閲覧できるオープンな情報です。  

AIに限らず、他のツールやサービスからも参照・分析されうるため、一般的には「モデル改善などのデータソースとなり得る」扱いと考えるのが自然です。  

そのため、次のような運用指針が現実的です。

- 機密情報や自社特有のノウハウが含まれるコードは、必ずプライベートリポジトリで運用する  
- 公開リポジトリは、「学習に使われても問題ない」とみなせる範囲にとどめる  

### 4.3 エンタープライズ利用時の考え方

Google WorkspaceやGoogle Cloudと組み合わせて利用する場合、  
利用規約やデータ処理契約（DPA）において、  
「顧客データをモデルの再学習には利用しない」といったポリシーが明示されるケースもあります。  

組織として導入を検討する際は、次の点を確認するのがよいでしょう。

1. 利用しているGoogleアカウントが、個人かWorkspace（組織）か  
2. Workspace / Cloud契約におけるAI関連のデータ利用ポリシー  
3. プロジェクトで扱うリポジトリが公開かプライベートか  
4. 社内の情報セキュリティポリシーとの整合性  

---

## 5. 仕様駆動開発（Spec-driven development）との関係

### 5.1 仕様駆動開発とは

**仕様駆動開発（Spec-driven development）**とは、  
「仕様（Spec）を開発の中心に置き、その仕様を起点にテストやコードを作っていくスタイル」の総称です。

典型的には、次のような流れになります。

1. まず人間が、要件や制約・受け入れ条件を**仕様書（Spec）として1カ所にまとめる**  
2. その仕様をもとに、テストやコードを生成・更新する  
3. 仕様と実装がズレないよう、常にSpecを“真実のソース”として扱う  

最近では、LLM（大規模言語モデル）を使って「仕様からコードを自動生成・変更する」ツールやフレームワークが増え、再び注目されています。

### 5.2 Julesと仕様駆動開発の相性

Julesは次のような特徴を持つため、仕様駆動開発と相性が良いとされています。

- リポジトリ全体のコードとドキュメントをコンテキストとして読み込める  
- タスクとして「この仕様書に従って実装を変更して」「このSpecの受け入れ条件を満たすテストを書いて」などの指示ができる  
- テストコマンドなどを事前に設定しておけば、Julesが自動でテストを実行し、結果を踏まえてPRを作る  

これにより、**人間が仕様と受け入れ条件を定義し、Julesがそれを満たすようにコードを変える**、という役割分担がしやすくなります。

### 5.3 実務的な運用イメージ

仕様駆動開発とJulesを組み合わせるときの、具体的なパターン例です。

1. **仕様ファイルを用意する**  
   - `docs/specs/feature-x.md` のような場所に、  
     - 背景  
     - 要件  
     - 非機能要件  
     - 受け入れ条件（Given / When / Then など）  
     をまとめておく。  

2. **GitHub Issueを仕様単位で作成する**  
   - Issue本文には、対応する仕様ファイルへのリンクと受け入れ条件を記載しておく。  

3. **Jules側で環境を設定する**  
   - リポジトリごとの設定画面で、依存関係インストールコマンドやテストコマンドを登録する  
   - 例：  
     ```bash
     npm install
     npm test
     ```  

4. **タスクとしてJulesに投げる**  
   - 「Issue #123 の仕様に従って、機能Xを実装しテストを追加してください」などの指示をタスクとして送る。  

5. **PRを仕様目線でレビューする**  
   - コードの書き方だけでなく、「仕様書に書かれた受け入れ条件をすべて満たしているか」を軸にレビューする。  

このサイクルを回すことで、**仕様 → テスト → コード**という流れが自然と徹底され、Julesは「仕様を実行するエージェント」として振る舞うようになります。

---

## 6. 始め方（クイックスタート）

ここでは、**無料プランでJulesを試す**ことを想定した、最小限の手順を紹介します。

### 6.1 前提条件

- GitHubアカウントを持っている  
- 小さめのサンプルリポジトリ（テスト付きだとベター）がある  

### 6.2 手順

#### Step 1. Julesにアクセスしてログイン

1. ブラウザでJulesのページ（例：`https://jules.google.com`）を開く  
2. Googleアカウントでログインする  

#### Step 2. GitHubリポジトリを接続

1. 「Add codebase」や「Connect GitHub」といったボタンから、GitHubとの連携を開始する  
2. OAuth画面で、Julesにアクセスさせたいリポジトリを選択する（最初は小さいリポジトリがおすすめ）  

#### Step 3. 環境とテストコマンドを設定

1. Julesの画面で、対象リポジトリの設定（Configuration）を開く  
2. 依存関係をインストールするコマンドや、テストを実行するコマンドを登録する  

   例：Node.jsプロジェクトの場合  

   ```bash
   npm install
   npm test
   ```  

#### Step 4. 最初のタスクを作成

1. 「New task」から、新しいタスクを作成する  
2. 説明文に、できるだけ具体的な指示を書く  

   例：  

   > `tests/` 以下のテストをすべて通るように、画像の重複検出ロジックをリファクタリングしてください。  
   > また、READMEの説明と実装内容の整合性を保ってください。  

3. タスクを送信すると、しばらくしてからGitHubにPRが作成される  

#### Step 5. PRをレビューする

- 変更内容やテスト結果を確認し、「この仕様や設計方針で問題ないか」を人間が判断する  
- 必要であれば、コメントを付けて追加の修正を依頼する  

---

## 7. 総評

### 7.1 強み

- **非同期でPRまでやってくれる**  
  - 大きめのリファクタリングや依存関係の更新など、「やや面倒な作業」を任せるのに向いています。  

- **長いコンテキストを扱えるモデルを利用**  
  - プロジェクト全体の構造を見たうえで変更してくれるため、局所的なコピペに比べて一貫性が保ちやすいです。  

- **Criticエージェントによるセルフレビュー**  
  - セキュリティ面や明らかなバグを減らす仕組みが組み込まれており、「丸投げ」の心理的ハードルを下げてくれます。  

- **仕様駆動開発との親和性**  
  - 仕様書とテストを整備しておけば、「仕様を満たすようにコードを変更してもらう」スタイルが取りやすくなります。  

### 7.2 注意点・弱み

- **「1行だけ直したい」といった小さな変更には向かない**  
  - ちょっとした修正なら、通常のチャット型AIやエディタ内のコパイロットの方が手早いケースも多いです。  

- **タスク設計力が必要**  
  - どの単位でタスクを切るか、どこまでをJulesに任せるか、といった「仕事の分解」がうまくいかないと、成果が安定しにくくなります。  

- **プランのタスク上限**  
  - 無料プランはあくまでお試し向けであり、本格的なチーム運用には有料プランが前提になります。  

### 7.3 まとめ

Julesは、  
- 「コードを書くAIアシスタント」というよりも、  
- 「仕様とテストを渡すとPRを返してくれる、準メンバーのようなエージェント」  

と捉えると、その特徴が理解しやすくなります。  

仕様とテストをきちんと整えられるチームほどJulesの効果を引き出しやすく、  
その一方で、行き当たりばったりな開発スタイルとはあまり相性がよくありません。  

まずは無料プランで小さなリポジトリを使って試し、  
- どのくらいのタスク粒度が適切か  
- どこまで任せると効率がよいか  

といった感覚を掴んでから、自分たちの開発プロセスにどう組み込むかを検討していくのがおすすめです。

---

## 8. 用語ミニ解説

### 非同期コーディングエージェント

ユーザーが指示を出したあと、リアルタイムに対話し続けるのではなく、  
裏側で長時間動き続け、作業が終わったタイミングで結果（PRなど）を返すタイプのAIエージェント。

### タスク

Julesにとっての1ユニットの仕事。  
多くの場合、PR1本分の修正に相当する粒度で扱われる。

### Criticエージェント

Jules内部で、Jules自身が書いたコードをチェックするAIエージェント。  
バグやセキュリティ上の問題などを検出し、必要に応じて書き直しを指示する役割を持つ。

### Gemini 2.5 Pro / 3 Pro

Googleの大規模言語モデルの世代。  
2.5 Proは長いコンテキストとマルチモーダル対応が特徴。  
3 Proは、より複雑なタスクや長い推論に強くなるよう改良された新世代モデルと位置付けられている。

### 仕様駆動開発（Spec-driven development）

仕様書（Spec）を開発の中心に置き、  
仕様 → テスト → コードという順序で進める開発スタイル。  
LLMエージェントを「仕様を満たすようにコードを変更する自動化ツール」として活用しやすい。  
